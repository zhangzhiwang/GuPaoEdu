<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:c="http://www.springframework.org/schema/c" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd">
		
	<!-- xml配置bean的常用方法 -->
<!-- 	<bean id="user1,user2,user3" name="u1,u2,u3" class="com.asiainfo.entity.User"></bean> -->
<!-- 	<bean id="user1" name="u1" class="com.asiainfo.entity.User" primary="true"></bean> -->
<!-- 	<bean id="user2" name="u2" class="com.asiainfo.entity.User"></bean> -->
<!-- 	<bean id="product" name="p1" class="com.asiainfo.entity.Product"></bean> -->
	
	<!-- xml配置bean的非常用方法：配置静态工程和动态工厂 -->
	<!-- 静态工厂 -->
	<!-- 注意class是静态工厂的全限定名，但id是工厂所生产的对象的名称而不是工厂的名称 -->
<!-- 	<bean id="userStatic" class="com.asiainfo.factory.StaticFactory" factory-method="getUserByStatic"></bean> -->
	
	<!-- 动态工厂 -->
	<!-- 通过动态工厂注入首先要配置一个动态工厂的bean，此时bean的id是动态工厂的名称，然后再配置工厂所生产对象的bean，并用factory-bean属性引用动态工厂对象 -->
<!-- 	<bean id="dynamicFactory" class="com.asiainfo.factory.DynamicFactory"></bean> -->
<!-- 	<bean id="userDynamic" factory-bean="dynamicFactory" factory-method="getUserByDynamic"></bean> -->

	<!-- 属性注入，属性注入的方式有两种：一个是通过构造器注入，一个是通过setter方法注入 -->
	<!-- 构造器注入方式1——通过入參名称注入，需要该类有相应的构造器 -->
<!-- 	<bean id="user4" class="com.asiainfo.entity.User"> -->
<!-- 		<constructor-arg name="name" value="zhaoliu"></constructor-arg> -->
<!-- 		<constructor-arg name="age" value="22"></constructor-arg> -->
<!-- 	</bean> -->
	<!-- 构造器注入方式1——通过入參名称注入（简写），简写的方式需要引入“xmlns:c”命名空间 -->
<!-- 	<bean id="user4" class="com.asiainfo.entity.User" c:name="赵六" c:age="23"></bean> -->
	
	<!-- 构造器注入方式2——通过参数顺序注入，需要该类有相应的构造器 -->
<!-- 	<bean id="user5" class="com.asiainfo.entity.User"> -->
<!-- 		<constructor-arg index="0" value="zhaoliu"></constructor-arg> -->
<!-- 		<constructor-arg index="1" value="22"></constructor-arg> -->
<!-- 	</bean> -->
	<!-- 构造器注入方式1——通过参数顺序注入（简写），简写的方式需要引入“xmlns:c”命名空间 -->
<!-- 	<bean id="user5" class="com.asiainfo.entity.User" c:_0="赵六" c:_1="23"></bean> -->
	
	<!-- setter方式注入，需要有相应属性的setter方法 -->
<!-- 	<bean id="user6" class="com.asiainfo.entity.User"> -->
<!-- 		<property name="name" value="张三"></property> -->
<!-- 		<property name="age" value="24"></property> -->
<!-- 	</bean> -->
	<!-- setter方式注入（简写），简写的方式需要引入“xmlns:p”命名空间 -->
<!-- 	<bean id="user6" class="com.asiainfo.entity.User" p:name="李四" p:age="25"></bean> -->

	<!-- 各种常见属性的注入 -->
<!-- 	<bean id="user7" class="com.asiainfo.entity.User"> -->
<!-- 		<property name="product" ref="product"> -->
<!-- 			<bean class="com.asiainfo.entity.Product" p:productId="2" p:productName="Huawei"></bean> -->
<!-- 		</property> -->
<!-- 		<property name="hobbies"> -->
<!-- 			<array> -->
<!-- 				<value>钢琴</value> -->
<!-- 				<value>羽毛球</value> -->
<!-- 			</array> -->
<!-- 		</property> -->
<!-- 		<property name="products"> -->
<!-- 			<list> -->
<!-- 				<bean class="com.asiainfo.entity.Product" p:productId="3" p:productName="Xioami"></bean> -->
<!-- 				<bean class="com.asiainfo.entity.Product" p:productId="4" p:productName="Vivo"></bean> -->
<!-- 			</list> -->
<!-- 		</property> -->
<!-- 		<property name="myMap"> -->
<!-- 			<map> -->
<!-- 				<entry key="username" value="root"></entry> -->
<!-- 				<entry key="password" value="root123"></entry> -->
<!-- 			</map> -->
<!-- 		</property> -->
<!-- 		<property name="properties"> -->
<!-- 			<props> -->
<!-- 				<prop key="url">localhost</prop> -->
<!-- 				<prop key="port">8080</prop> -->
<!-- 			</props> -->
<!-- 		</property> -->
<!-- 	</bean> -->
<!-- 	<bean id="product" class="com.asiainfo.entity.Product" p:productId="1" p:productName="Apple"></bean> -->

<!-- 	<bean id="userController" class="com.asiainfo.controller.UserController"> -->
<!-- 		<property name="userService" ref="userService"></property> -->
<!-- 	</bean> -->
<!-- 	<bean id="userService" class="com.asiainfo.service.impl.UserServiceImpl" p:userDao-ref="userDao"></bean> -->
<!-- 	<bean id="userDao2" class="com.asiainfo.dao.impl.UserDaoImpl"></bean> -->

<!-- 	<context:component-scan base-package="com.asiainfo"></context:component-scan> -->
	<!-- 如果需要扫描多个包可以有两种方式 -->
	<!-- 方式1:使用多个<context:component-scan>标签，每个标签配置一个包 -->
	<!-- @Controller、@Service、@Repository本质上都是@Component，它们之间可以混用。之所以它们之间可以混用是因为使用的是默认过滤器，但是混用会对代码的可读性带来误解，所以可以限制某一层用什么注解。 -->
	<!-- <context:component-scan base-package="com.asiainfo.controller" use-default-filters="false"> -->	<!-- 如果规定controller层只能使用@Controller注解，必须关掉默认过滤器 -->
		<!-- 使用context:include-filter标签，expression的值是@Controller的全限定名，type使用annotation，这样controller层只能使用@Controller注解 -->
<!-- 		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
<!-- 	</context:component-scan> -->
<!-- 	<context:component-scan base-package="com.asiainfo.service" use-default-filters="true"> -->
		<!-- service层使用默认过滤器，但是使用了context:exclude-filter标签，表示service包下的类不能使用@Controller注解，但是可以混用其他注解 -->
<!-- 		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> -->
<!-- 	</context:component-scan> -->
<!-- 	<context:component-scan base-package="com.asiainfo.dao"></context:component-scan> -->
	<!-- 方式2：base-package属性配置多个包并用逗号分割 -->
<!-- 	<context:component-scan base-package="com.asiainfo.controller,com.asiainfo.service,com.asiainfo.dao"></context:component-scan> -->

	<!-- <bean id="product" class="com.asiainfo.entity.Product" lazy-init="true"></bean> -->	<!-- 延迟加载 -->
	
	<!-- 以配置的方式使用事务 -->
	<context:property-placeholder location="classpath:db.properties"/>
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${db.driver}"></property>
		<property name="url" value="${db.url}"></property>
		<property name="username" value="${db.username}"></property>
		<property name="password" value="${db.password}"></property>
	</bean>
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
<!-- 	<tx:advice id="advice1" transaction-manager="txManager"> -->
<!-- 		<tx:attributes> -->
<!-- 			<tx:method name="service*" propagation="REQUIRED" isolation="DEFAULT"/> -->
<!--             other methods use the default transaction settings (see below) -->
<!--             <tx:method name="*"/> -->
<!-- 		</tx:attributes> -->
<!-- 	</tx:advice> -->
<!-- 	<aop:config> -->
<!-- 		<aop:pointcut expression="execution(* com.asiainfo.transaction.TxService.serviceMethod(..))" id="pointcut1"/> -->
<!-- 		<aop:advisor advice-ref="advice1" pointcut-ref="pointcut1"/> -->
<!-- 	</aop:config> -->
<!-- 	<bean id="txService" class="com.asiainfo.transaction.TxService"> -->
<!-- 		<property name="dao1" ref="dao1"></property> -->
<!-- 		<property name="dao2" ref="dao2"></property> -->
<!-- 	</bean> -->
<!-- 	<bean id="dao1" class="com.asiainfo.transaction.Dao1"></bean> -->
<!-- 	<bean id="dao2" class="com.asiainfo.transaction.Dao2"></bean> -->

	<!-- 以注解的方式使用事务 -->
	<tx:annotation-driven transaction-manager="txManager"/>
	
	<!-- 
		为什么在Spring的配置文件里面context:component-scan标签的属性use-default-filters设置为true，然后子标签用exclude-filter；而mvc的配置文件里面use-default-filters为false，子标签用include-filter呢？
		我们要达到这样一个效果：Spring要扫描除@Controller外的所有注解，mvc只扫描@Controller注解不能扫描别的。
		use-default-filters的默认值是true，即扫描所有@Component的注解（当然还有两外连两个，下面会提到），然后在这些注解里面排除掉exclude-filter配置的注解；
		use-default-filters如果设置为false，那么就不扫描任何注解，只扫描用户自定义的注解，即用include-filter制定的注解。
		
		结合源码层面，与context:component-scan相对应的源码在org.springframework.context.config.ContextNamespaceHandler的第38行：
		1、找到第38行，进入ComponentScanBeanDefinitionParser类
		2、这个类里面只有一个pbluc方法——parse方法，所以就看这个方法
		3、parse方法的关键在于89行的configureScanner方法
		4、进入configureScanner方法可以看到useDefaultFilters的默认值是true，如果用户配置了就用用户配置的值，然后将此值传给了第103行的createScanner方法
		5、进入createScanner方法，接着进入ClassPathBeanDefinitionScanner的构造方法
		6、进入ClassPathBeanDefinitionScanner的构造方法之后关键代码在第165行，如果是true，那么就执行registerDefaultFilters方法，否则不执行，那么关键就在registerDefaultFilters方法了
		7、进入registerDefaultFilters方法可以看到，默认将@Component、ManagedBean和Named加入到ClassPathScanningCandidateComponentProvider的includeFilters属性里面，
		   而@Controller、@Service、@Repository的本质就是@Component，所以在默认情况下（即use-default-filters=true的时候）会扫描所有注解。如果use-default-filters为false，那么本方法不会执行，也就是includeFilters的值就是空。
		8、逐步返回到ComponentScanBeanDefinitionParser.configureScanner方法的第125行，进入parseTypeFilters方法
		9、进入该方法可以看到如果用户配置了exclude或者include的自标签，那么会将相应标签的值放入ClassPathScanningCandidateComponentProvider的includeFilters属性里面或者excludeFilters属性里面。
		   如果use-default-filters为false，那么现在includeFilters里面只有用户在include自标签里面配置的注解
		10、（如果use-default-filters=true，那么什么时候从includeFilters里面把excludeFilters的注解排除掉就不知道了，尚且没有找到相关的源码）
		至此，应该知道为什么spring的配置文件里面的use-default-filters要为true，而且使用exclude-filter把@Controller注解排除掉了，还有为什么mvc的配置文件里面use-default-filters为false，使用include-filter自标签将@Controller注解注解添加进去了
	 -->
	<context:component-scan base-package="com.asiainfo" use-default-filters="true">
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	<!-- 集成mybatis -->
	<bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"></property>
		<property name="configLocation" value="classpath:myBatis-config.xml"></property>
		<property name="mapperLocations" value="classpath:mapper/*.xml"></property>
	</bean>
	
	<bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.asiainfo.mapper"></property>
	</bean>
</beans>