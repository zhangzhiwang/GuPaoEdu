<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  
  <!-- 
  	mvc的执行流程（标*的为servlet的知识点）：
  	1、*根据servlet规范，所有servlet必须在web.xml中进行配置，web容器启动的时候会加载配置在web.xml中的servlet
  	2、*根据servlet规范，容器启动后会加载配置的servlet，然后进行出实话操作，即调用init()方法
  	3、DispatcherServlet的init方法在其父类HttpServletBean里面，这里面的关键代码是第170行的initServletBean()方法
  	4、initServletBean()方法的实现在HttpServletBean的子类FrameworkServlet（仍然是DispatcherServlet的父类）中，里面的关键代码是第530行的initWebApplicationContext()方法
  	5、进入initWebApplicationContext()方法，通过debug可以知道WebApplicationContext的实现类是XmlWebApplicationContext，里面有两处关键代码：
  	（1）第591行的createWebApplicationContext(rootContext)
  		进入该方法，寻找路径是：createWebApplicationContext() -> configureAndRefreshWebApplicationContext(wac) -> wac.refresh() -> 进入wac.refresh()就可以看到里面的模版方法模式，即可知道是对ioc容器的初始化
  	（2）第599行的onRefresh(wac)
  		进入该方法，寻找路径是：进入DispatcherServlet的onRefresh()方法 -> initStrategies(context) -> 可以看到一个模版方法模式，是对mvc九大组件的初始化
  		对九大组件的初始化，进入任意一个初始化的方法可以看出来初始化的代码逻辑结构都是一样的：首先从mvc配置文件中找到配置的组建，如果没有配置就是用默认的组件。其中获取默认的自建的代码是getDefaultStrategies方法，点进去可以看到有一个叫defaultStrategies的成员变量，
  		而该成员变量是从一个叫DispatcherServlet.properties的配置见里面读取的默认组件配置，该文件就在spring-webmvc的jar里面的org.springframework.web.servlet包下
  	6、init方法结束。通过init方法可以知道主要干了两件事情：一个是对ioc容器的初始化，一个是对mvc九大组件的初始化。
  	7、*根据servlet规范，初始化init方法只会在客户端第一次请求的时候被调用一次，以后客户端每次请求的时候都会调用servlet类的service方法
  	8、以上是初始化过程，下面是service方法的流程：当客户端访问时调用DispatcherServlet的service方法，该方法在其父类FrameworkServlet中，寻找路径是：FrameworkServlet.service() -> super.service(request, response) -> HttpServlet.doGet(req, resp)（以get举例） -> 进入子类FrameworkServlet.doGet(req, resp) -> processRequest(request, response) -> doService(request, response)
  	   -> 进入子类DispatcherServlet.doService() -> doDispatch(request, response) -> ha.handle(processedRequest, response, mappedHandler.getHandler()) -> SimpleControllerHandlerAdapter.handle() -> 进入自定义Controller实现类UserController的handleRequest方法。以上流程是在不使用注解的时候的流程。
  	   使用注解的查找路径：？？？
  	   
  	mvc的整体流程：
  	1、客户端的请求被前端控制器拦截
  	2、前端控制器会讲请求转发给处理器映射器
  	3、处理器映射器找到对应的处理器（Handler，也就是Controller）之后返回给前端控制器
  	4、前端控制器拿到处理器之后将其转发给处理器适配器，处理器适配器去调用处理器的相应方法并返回ModelAndView给前端控制器
  	5、前端控制器拿到ModelAndView之后会转发给视图解析器，视图解析器拿到ModelAndView之后会根据view部分的逻辑视图名找到真正的页面文件并封装成View对象返回给前端控制器
  	6、前端控制器拿到View对象之后进行视图渲染并返回给客户端，结束！注意：视图的渲染不是在视图解析器中进行的，而是视图解析器返回View对象给前端控制器之后，前端控制器利用View对象进行渲染的，所以渲染的地点在前端控制器。
  	整个过程在DispatcherServlet的doDispatch()方法中体现：
  	1、第1016行对应上面的2、3步
  	2、第1040行对应上面的4步
  	3、第1057行对应上面的5、6步，其中render方法的第1349行对应第5步，1372行对应第6步
   -->
  
  <!-- 配置mvc最核心的组件——前端控制器DispatcherServlet -->
  <!-- DispatcherServlet本质就是一个servlet，是servlet就要配置在web.xml中以及初始化的时候会执行所配置servlet的init方法（具体可以系统学习一下servlet及其相关规范） -->
  <servlet>
  	<servlet-name>spring_mvc</servlet-name>
  	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  	<init-param>	<!-- 初始化参数 -->
  		<param-name>contextConfigLocation</param-name>	<!-- 在DispatcherServlet的父类FrameworkServlet可以找到该属性 -->
  		<param-value>classpath:spring-mvc.xml</param-value>	<!-- 值是mvc的配置文件路径（在初始化servlet的时候如果配置了init-param，应该是会自动调用该属性的setter方法（猜测是这样的，可以在系统学习servlet技术之后给出答案）） -->
  	</init-param>
  </servlet>
  
  <servlet-mapping>
  	<servlet-name>spring_mvc</servlet-name>
  	<url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
