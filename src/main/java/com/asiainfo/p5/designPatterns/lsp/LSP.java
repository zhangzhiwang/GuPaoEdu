package com.asiainfo.p5.designPatterns.lsp;

import java.util.List;

/**
 * 里氏替换原则LSP（Liskov Substitution Principle）：子类可以完全替换父类并且替换后原有程序不能表现出不一样的行为。
 *
 * @author zhangzhiwang
 * @date Feb 20, 2020 11:34:52 AM
 */
public class LSP {
	public static void main(String[] args) {
		/**
		  * 在说里氏替换原则之前先复习下方法重写的部分规则：</p>
		  *  重写规则1：子类重写父类的方法，那么方法名和参数列表必须完全一致。“完全一致”的意思就是子类方法的入參范围不能比父类的大或者小，而是完全相等。</p>
		  *  重写规则2：子类方法的返回值类型的范围不能比父类的大。</p>
		  *  重写规则3：子类实现父类的抽象方法的规则和子类复写父类非抽象方法的规则是一样的，这些规则包括方法名、参数列表、方法访问控制权限、方法返回值类型范围、声明抛出异常的范围。</p>
		  *  其它规则略。</p>
		  *  我们说LSP原则是在方法重载和方法重写的原则之上提出来的，即LSP的前提是必须满足方法重载和方法重写的规则。
		  */
		
		/**
		 * LSP规则：</p>
		 * 1、为了使父类对象替换为子类对象之后原程序保持行为不变，那么子类不能复写任何父类的非抽象方法，也就是在多态的情况下引用调用的方法仍然是父类的方法。</p>
		 * 2、子类可以实现父类的抽象方法以及可以添加子类特有的方法(只不过特有的方法在多态的情况下调用不到而已)。</p>
		 * 3、当子类重载父类的方法时，方法的入參的范围要比父类的更大。子类可以重载父类的方法，但怎么保证替换成子类后执行的还是父类的方法呢？根据方法重载的就近原则，只有子类入參的范围比父类的更大传入一个范围小的入參的时候最终调用的才会是父类的方法</p>
		 * 4、当子类重载父类的方法时，方法的返回值参数的范围不能比父类的更大。因为服务的提供方对外暴露的是父类的接口，所以调用方只能按照按照父类的接口规范来进行编程。当服务提供方默默地将服务的实现由父类替换成子类后（这个事情调用方是不知道的），只有子类的返回值范围更小才能保证调用方的接收返回值的代码是安全的。
		 */
		
		// LSP举一个简单的例子：原来客户端调用getUserList方法时，返回值永远不会为null，所以拿过来可以直接用；但是默默替换成子类后有可能返回null，所以客户端就有可能报错
		Father f = new Father();
		List userList = f.getUserList();
		int size = userList.size();// 在父类的getUserList方法里面返回的List永远不会为null，而在子类的返回中可能为null，这样就是原程序的行为改变了。
		System.out.println(size);
	}
}
